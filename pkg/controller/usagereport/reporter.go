package usagereport

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"os"
	"runtime"
	"time"

	"github.com/google/uuid"
	"gopkg.in/yaml.v2"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/util/wait"
	coreinformers "k8s.io/client-go/informers/core/v1"
	clientset "k8s.io/client-go/kubernetes"
	corelisters "k8s.io/client-go/listers/core/v1"
	"k8s.io/client-go/tools/cache"
	"k8s.io/klog/v2"

	"antrea.io/antrea/pkg/clusteridentity"
	"antrea.io/antrea/pkg/controller/networkpolicy"
	"antrea.io/antrea/pkg/controller/usagereport/api"
	"antrea.io/antrea/pkg/features"
	"antrea.io/antrea/pkg/util/env"
	"antrea.io/antrea/pkg/version"
)

const (
	scCollectorId             = "antrea-telemetry"
	scTableName               = "antrea_usage_report"
	defaultReportInterval     = 24 * time.Hour
	defaultReportInitialDelay = 30 * time.Minute
	defaultAntreaNamespace    = "kube-system"
)

var (
	stagingServerURL    = fmt.Sprintf("https://scapi-stg.vmware.com/sc/api/collectors/%s/batch", scCollectorId)
	productionServerURL = fmt.Sprintf("https://scapi.vmware.com/sc/api/collectors/%s/batch", scCollectorId)
)

type agentConfig struct {
	FeatureGates            map[string]bool `yaml:"featureGates,omitempty"`
	OVSDatapathType         string          `yaml:"ovsDatapathType,omitempty"`
	TrafficEncapMode        string          `yaml:"trafficEncapMode,omitempty"`
	NoSNAT                  bool            `yaml:"noSNAT,omitempty"`
	TunnelType              string          `yaml:"tunnelType,omitempty"`
	EnableIPSecTunnel       bool            `yaml:"enableIPSecTunnel,omitempty"`
	EnablePrometheusMetrics bool            `yaml:"enablePrometheusMetrics,omitempty"`
}

type controllerConfig struct {
	FeatureGates            map[string]bool `yaml:"featureGates,omitempty"`
	EnablePrometheusMetrics bool            `yaml:"enablePrometheusMetrics,omitempty"`
}

// TODO: avoid duplicating defaults from cmd package

var (
	agentConfigDefaults = agentConfig{
		OVSDatapathType:         "system",
		TrafficEncapMode:        "encap",
		NoSNAT:                  false,
		TunnelType:              "geneve",
		EnableIPSecTunnel:       false,
		EnablePrometheusMetrics: true,
	}
	controllerConfigDefaults = controllerConfig{
		EnablePrometheusMetrics: true,
	}
)

// antreaTelemetryIsStaging returns true if the ANTREA_TELEMETRY_STAGING environment variable is
// set. This variable is used for testing purposes only and will ensure that telemetry reports are
// sent to the staging tables in SuperCollider, and not the production tables. You can set it for
// the antrea-controller Pod in the Antrea YAML manifest if needed for testing.
func antreaTelemetryIsStaging() bool {
	_, isSet := os.LookupEnv("ANTREA_TELEMETRY_STAGING")
	return isSet
}

func parsedTimeDurationOrDefault(envName string, defaultDuration time.Duration) time.Duration {
	durationString, isSet := os.LookupEnv(envName)
	if !isSet {
		return defaultDuration
	}
	duration, err := time.ParseDuration(durationString)
	if err != nil {
		klog.Warningf("Invalid value for '%s', will use %v: %v", envName, defaultDuration, err)
		return defaultDuration
	}
	return duration
}

// antreaTelemetryDefaultReportInitialDelay returns the default duration to wait before sending the
// first telemetry report to SuperCollider. If the ANTREA_TELEMETRY_REPORT_INITIAL_DELAY environment
// variable is set, the value of the variable will be used. This variable is used for testing
// purposes to reduce the default duration, which is 30 minutes. The value of the variable must be a
// valid Golang duration string (e.g. "1m" for 1 minute). You can set it for the antrea-controller
// Pod in the Antrea YAML manifest if needed for testing.
func antreaTelemetryDefaultReportInitialDelay() time.Duration {
	return parsedTimeDurationOrDefault("ANTREA_TELEMETRY_REPORT_INITIAL_DELAY", defaultReportInitialDelay)
}

// antreaTelemetryDefaultReportInterval returns the default time interval between 2 successive
// telemetry reports. If the ANTREA_TELEMETRY_REPORT_INTERVAL environment variable is set, the value
// of the variable will be used. This variable is used for testing purposes to reduce the default
// interval, which is 24 hours. The value of the variable must be a valid Golang duration
// string (e.g. "5m" for 5 minutes). You can set it for the antrea-controller Pod in the Antrea YAML
// manifest if needed for testing.
func antreaTelemetryDefaultReportInterval() time.Duration {
	return parsedTimeDurationOrDefault("ANTREA_TELEMETRY_REPORT_INTERVAL", defaultReportInterval)
}

// getAntreaConfigMapName returns the name (usually auto-generated by kustomize, with a hash suffix)
// of the Antrea ConfigMap.
func getAntreaConfigMapName() string {
	// The ANTREA_CONFIG_MAP_NAME environment variable must be set in the Antrea YAML manifest,
	// for the antrea-controller Pod.
	const antreaConfigMapNameEnvKey = "ANTREA_CONFIG_MAP_NAME"
	antreaConfigMapName := os.Getenv(antreaConfigMapNameEnvKey)
	if antreaConfigMapName == "" {
		klog.Warningf("Environment variable %s not found", antreaConfigMapNameEnvKey)
	}
	return antreaConfigMapName
}

type ReporterConfig struct {
	ServerURL           string
	ReportInterval      time.Duration
	ReportInitialDelay  time.Duration
	AntreaNamespace     string
	AntreaConfigMapName string
}

type Reporter struct {
	ReporterConfig
	k8sClient               clientset.Interface
	clusterUUID             uuid.UUID
	nodeInformer            coreinformers.NodeInformer
	nodeLister              corelisters.NodeLister
	nodeListerSynced        cache.InformerSynced
	podLister               corelisters.PodLister
	podListerSynced         cache.InformerSynced
	namespaceLister         corelisters.NamespaceLister
	namespaceListerSynced   cache.InformerSynced
	clusterIdentityProvider clusteridentity.ClusterIdentityProvider
	// networkPolicyUsageReporter is an interface pointer to the Antrea
	// NetworkPolicyController. It is useful to retrieve some stats about the cluster, which are
	// already available to the Controller, without having to duplicate all the informers
	// here. In the future, it may also be useful to provide more advanced stats, based on the
	// objects computed by the Controller.
	networkPolicyUsageReporter networkpolicy.NetworkPolicyUsageReporter
	antreaDeploymentTime       time.Time
	agentConfig                *api.AgentConfig
	controllerConfig           *api.ControllerConfig
}

func NewReporter(
	k8sClient clientset.Interface,
	nodeInformer coreinformers.NodeInformer,
	podInformer coreinformers.PodInformer,
	namespaceInformer coreinformers.NamespaceInformer,
	clusterIdentityProvider clusteridentity.ClusterIdentityProvider,
	networkPolicyUsageReporter networkpolicy.NetworkPolicyUsageReporter,
	configFns ...func(*ReporterConfig),
) *Reporter {
	config := ReporterConfig{
		ReportInterval:     antreaTelemetryDefaultReportInterval(),
		ReportInitialDelay: antreaTelemetryDefaultReportInitialDelay(),
	}
	if antreaTelemetryIsStaging() {
		config.ServerURL = stagingServerURL
	} else {
		config.ServerURL = productionServerURL
	}
	for _, fn := range configFns {
		fn(&config)
	}
	r := &Reporter{
		ReporterConfig:             config,
		k8sClient:                  k8sClient,
		nodeInformer:               nodeInformer,
		nodeLister:                 nodeInformer.Lister(),
		nodeListerSynced:           nodeInformer.Informer().HasSynced,
		podLister:                  podInformer.Lister(),
		podListerSynced:            podInformer.Informer().HasSynced,
		namespaceLister:            namespaceInformer.Lister(),
		namespaceListerSynced:      namespaceInformer.Informer().HasSynced,
		clusterIdentityProvider:    clusterIdentityProvider,
		networkPolicyUsageReporter: networkPolicyUsageReporter,
	}
	return r
}

func (r *Reporter) GetNumNamespaces() (int, error) {
	list, err := r.namespaceLister.List(labels.Everything())
	if err != nil {
		return 0, fmt.Errorf("error when listing Namespaces: %v", err)
	}
	return len(list), nil
}

func (r *Reporter) GetNumPods() (int, error) {
	list, err := r.podLister.List(labels.Everything())
	if err != nil {
		return 0, fmt.Errorf("error when listing Pods: %v", err)
	}
	return len(list), nil
}

func (r *Reporter) getNodes() ([]api.NodeInfo, error) {
	nodes, err := r.nodeLister.List(labels.Everything())
	if err != nil {
		return nil, fmt.Errorf("error when listing all Nodes: %v", err)
	}

	nodesInfo := make([]api.NodeInfo, 0, len(nodes))
	for _, node := range nodes {
		var hasIPv4Address, hasIPv6Address bool
		for _, addr := range node.Status.Addresses {
			if addr.Type != corev1.NodeInternalIP {
				continue
			}
			ip := net.ParseIP(addr.Address)
			if ip != nil {
				hasIPv4Address = hasIPv4Address || (ip.To4() != nil)
				hasIPv6Address = hasIPv6Address || (ip.To4() == nil)
			}
		}
		i := &node.Status.NodeInfo
		nodesInfo = append(nodesInfo, api.NodeInfo{
			KernelVersion:           i.KernelVersion,
			OSImage:                 i.OSImage,
			ContainerRuntimeVersion: i.ContainerRuntimeVersion,
			KubeletVersion:          i.KubeletVersion,
			KubeProxyVersion:        i.KubeProxyVersion,
			OperatingSystem:         i.OperatingSystem,
			Architecture:            i.Architecture,
			HasIPv4Address:          hasIPv4Address,
			HasIPv6Address:          hasIPv6Address,
		})
	}
	return nodesInfo, nil
}

func (r *Reporter) getK8sAPIVersion() (string, error) {
	serverVersion, err := r.k8sClient.Discovery().ServerVersion()
	if err != nil {
		return "", err
	}
	return serverVersion.String(), nil
}

func (r *Reporter) getAntreaConfig() (*api.AgentConfig, *api.ControllerConfig, error) {
	configMap, err := r.k8sClient.CoreV1().ConfigMaps(r.AntreaNamespace).Get(context.TODO(), r.AntreaConfigMapName, metav1.GetOptions{})
	if err != nil {
		return nil, nil, fmt.Errorf("error when getting ConfigMap \"%s/%s\": %v", r.AntreaNamespace, r.AntreaConfigMapName, err)
	}
	addDefaultFeatureGates := func(featureGates map[string]bool) []api.FeatureGate {
		defaultAntreaFeatureGates := features.DefaultAntreaFeatureGates
		r := make([]api.FeatureGate, 0)
		for feature, spec := range defaultAntreaFeatureGates {
			if enabled, ok := featureGates[string(feature)]; ok {
				r = append(r, api.FeatureGate{Name: string(feature), Enabled: enabled})
			} else {
				r = append(r, api.FeatureGate{Name: string(feature), Enabled: spec.Default})
			}
		}
		return r
	}

	agentConfigIn := agentConfigDefaults
	if err := yaml.Unmarshal([]byte(configMap.Data["antrea-agent.conf"]), &agentConfigIn); err != nil {
		return nil, nil, fmt.Errorf("error when unmarshalling Agent configuration: %v", err)
	}
	agentConfigOut := api.AgentConfig{
		FeatureGates:            addDefaultFeatureGates(agentConfigIn.FeatureGates),
		OVSDatapathType:         agentConfigIn.OVSDatapathType,
		TrafficEncapMode:        agentConfigIn.TrafficEncapMode,
		NoSNAT:                  agentConfigIn.NoSNAT,
		TunnelType:              agentConfigIn.TunnelType,
		EnableIPSecTunnel:       agentConfigIn.EnableIPSecTunnel,
		EnablePrometheusMetrics: agentConfigIn.EnablePrometheusMetrics,
	}

	controllerConfigIn := controllerConfigDefaults
	if err := yaml.Unmarshal([]byte(configMap.Data["antrea-controller.conf"]), &controllerConfigIn); err != nil {
		return nil, nil, fmt.Errorf("error when unmarshalling Controller configuration: %v", err)
	}
	controllerConfigOut := api.ControllerConfig{
		FeatureGates:            addDefaultFeatureGates(controllerConfigIn.FeatureGates),
		EnablePrometheusMetrics: controllerConfigIn.EnablePrometheusMetrics,
	}

	return &agentConfigOut, &controllerConfigOut, nil
}

func (r *Reporter) getPrimaryIPFamily() (api.IPFamily, error) {
	k8sServiceHost := os.Getenv("KUBERNETES_SERVICE_HOST")
	if k8sServiceHost == "" {
		return api.IPFamilyIPv4, fmt.Errorf("KUBERNETES_SERVICE_HOST is not set")
	}
	ip := net.ParseIP(k8sServiceHost)
	if ip == nil {
		return api.IPFamilyIPv4, fmt.Errorf("KUBERNETES_SERVICE_HOST is not a valid IP")
	}
	if ip.To4() != nil {
		return api.IPFamilyIPv4, nil
	}
	return api.IPFamilyIPv6, nil
}

func (r *Reporter) getK8sDistribution() api.K8sDistributionName {
	// TODO: support more distributions
	switch {
	case env.IsCloudEKS():
		return api.K8sDistributionEKS
	default:
		return api.K8sDistributionUnknown
	}
}

func (r *Reporter) getControllerRuntimeInfo() *api.RuntimeInfo {
	var memStats runtime.MemStats
	runtime.ReadMemStats(&memStats)
	return &api.RuntimeInfo{
		NumGoroutine: int32(runtime.NumGoroutine()),
		NumCPU:       int32(runtime.NumCPU()),
		MemoryStats: api.MemStats{
			HeapAlloc: memStats.HeapAlloc,
			Sys:       memStats.Sys,
			Mallocs:   memStats.Mallocs,
			Frees:     memStats.Frees,
		},
	}
}

func (r *Reporter) generateReport() *api.UsageReport {
	nodesInfo, err := r.getNodes()
	var numNodesPtr *int32
	if err != nil {
		klog.V(2).Infof("Could not get system info for Nodes, omitting in report: %v", err)
	} else {
		numNodesPtr = new(int32)
		*numNodesPtr = int32(len(nodesInfo))
	}
	k8sVersion, err := r.getK8sAPIVersion()
	if err != nil {
		klog.V(2).Infof("Could not get K8s API version, omitting in report: %v", err)
	}

	var hasIPv4Address, hasIPv6Address bool
	for _, node := range nodesInfo {
		hasIPv4Address = hasIPv4Address || node.HasIPv4Address
		hasIPv6Address = hasIPv6Address || node.HasIPv6Address
	}
	primaryIPFamily, err := r.getPrimaryIPFamily()
	var ipFamilies []api.IPFamily
	if err != nil {
		klog.V(2).Infof("Could not determine primary IP family for cluster, will default to IPv4 in report if enabled: %v", err)
		if hasIPv4Address {
			ipFamilies = append(ipFamilies, api.IPFamilyIPv4)
		}
		if hasIPv6Address {
			ipFamilies = append(ipFamilies, api.IPFamilyIPv6)
		}
	} else {
		switch {
		case hasIPv4Address && hasIPv6Address && primaryIPFamily == api.IPFamilyIPv4:
			ipFamilies = []api.IPFamily{api.IPFamilyIPv4, api.IPFamilyIPv6}
		case hasIPv4Address && hasIPv6Address && primaryIPFamily == api.IPFamilyIPv6:
			ipFamilies = []api.IPFamily{api.IPFamilyIPv6, api.IPFamilyIPv4}
		case hasIPv4Address && primaryIPFamily == api.IPFamilyIPv4:
			ipFamilies = []api.IPFamily{api.IPFamilyIPv4}
		case hasIPv6Address && primaryIPFamily == api.IPFamilyIPv6:
			ipFamilies = []api.IPFamily{api.IPFamilyIPv6}
		default:
			klog.V(2).Infof("Encountered invalid case when determining cluster IP families")
		}
	}

	var numNamespacesPtr *int32
	numNamespaces, err := r.GetNumNamespaces()
	if err != nil {
		klog.V(2).Infof("Could not get Namespace count, omitting in report: %v", err)
	} else {
		numNamespacesPtr = new(int32)
		*numNamespacesPtr = int32(numNamespaces)
	}
	var numPodsPtr *int32
	numPods, err := r.GetNumPods()
	if err != nil {
		klog.V(2).Infof("Could not get Pod count, omitting in report: %v", err)
	} else {
		numPodsPtr = new(int32)
		*numPodsPtr = int32(numPods)
	}
	var numTiersPtr *int32
	numTiers, err := r.networkPolicyUsageReporter.GetNumTiers()
	if err != nil {
		klog.V(2).Infof("Could not get Tier count, omitting in report: %v", err)
	} else {
		numTiersPtr = new(int32)
		*numTiersPtr = int32(numTiers)
	}
	var numNetworkPoliciesPtr *int32
	numNetworkPolicies, err := r.networkPolicyUsageReporter.GetNumNetworkPolicies()
	if err != nil {
		klog.V(2).Infof("Could not get NetworkPolicy count, omitting in report: %v", err)
	} else {
		numNetworkPoliciesPtr = new(int32)
		*numNetworkPoliciesPtr = int32(numNetworkPolicies)
	}
	var numAntreaNetworkPoliciesPtr *int32
	numAntreaNetworkPolicies, err := r.networkPolicyUsageReporter.GetNumAntreaNetworkPolicies()
	if err != nil {
		klog.V(2).Infof("Could not get AntreaNetworkPolicy count, omitting in report: %v", err)
	} else {
		numAntreaNetworkPoliciesPtr = new(int32)
		*numAntreaNetworkPoliciesPtr = int32(numAntreaNetworkPolicies)
	}
	var numAntreaClusterNetworkPoliciesPtr *int32
	numAntreaClusterNetworkPolicies, err := r.networkPolicyUsageReporter.GetNumAntreaClusterNetworkPolicies()
	if err != nil {
		klog.V(2).Infof("Could not get AntreaClusterNetworkPolicy count, omitting in report: %v", err)
	} else {
		numAntreaClusterNetworkPoliciesPtr = new(int32)
		*numAntreaClusterNetworkPoliciesPtr = int32(numAntreaClusterNetworkPolicies)
	}

	k8sDistribution := r.getK8sDistribution()

	controllerRuntimeInfo := r.getControllerRuntimeInfo()

	return &api.UsageReport{
		ClusterUUID:      r.clusterUUID.String(),
		Version:          version.Version,
		FullVersion:      version.GetFullVersion(),
		IsReleased:       version.ReleaseStatus == "released",
		AgentConfig:      r.agentConfig,
		ControllerConfig: r.controllerConfig,
		ClusterInfo: api.ClusterInfo{
			K8sVersion:            k8sVersion,
			K8sDistribution:       k8sDistribution,
			NumNodes:              numNodesPtr,
			Nodes:                 nodesInfo,
			ControllerRuntimeInfo: *controllerRuntimeInfo,
			NumNamespaces:         numNamespacesPtr,
			NumPods:               numPodsPtr,
			NetworkPolicies: api.NetworkPolicyInfo{
				NumTiers:                        numTiersPtr,
				NumNetworkPolicies:              numNetworkPoliciesPtr,
				NumAntreaNetworkPolicies:        numAntreaNetworkPoliciesPtr,
				NumAntreaClusterNetworkPolicies: numAntreaClusterNetworkPoliciesPtr,
			},
			IPFamilies: ipFamilies,
		},
		AntreaDeploymentTime: r.antreaDeploymentTime,
	}
}

// scUsageReport adds mandattory field when sending report to the VMware SuperCollider API
type scUsageReport struct {
	api.UsageReport
	Table string `json:"@table"`
}

func (r *Reporter) sendReport() error {
	report := r.generateReport()
	scReport := &scUsageReport{*report, scTableName}

	url := r.ServerURL
	jsonBytes, err := json.Marshal(scReport)
	if err != nil {
		return fmt.Errorf("error when marshalling JSON report: %v", err)
	}
	klog.V(4).Infof("Usage report has size %d bytes", len(jsonBytes))
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonBytes))
	if err != nil {
		return fmt.Errorf("error when building HTTP request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("error when posting JSON report to \"%s\": %v", url, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("error when posting JSON report to \"%s\": %v", url, err)
	}

	return nil
}

func (r *Reporter) Run(stopCh <-chan struct{}) {
	klog.Infof("Starting usage reporter")

	cacheSyncs := []cache.InformerSynced{r.nodeListerSynced, r.podListerSynced, r.namespaceListerSynced}
	if !cache.WaitForNamedCacheSync("usage reporter", stopCh, cacheSyncs...) {
		return
	}

	// useful for unit tests, to avoid warnings
	if r.AntreaNamespace == "" {
		namespace := env.GetPodNamespace()
		if namespace == "" {
			klog.Warningf("Failed to get Pod Namespace from environment; using \"%s\" as the ConfigMap Namespace", defaultAntreaNamespace)
			namespace = defaultAntreaNamespace
		}
		r.AntreaNamespace = namespace
	}

	// useful for unit tests, to support defining an arbitrary test ConfigMap
	if r.AntreaConfigMapName == "" {
		r.AntreaConfigMapName = getAntreaConfigMapName()
		if r.AntreaConfigMapName == "" {
			klog.Warningf("Failed to get Antrea ConfigMap name from environment; some information will be missing from usage reports")
		}
	}

	const retryInterval = time.Second

	if err := wait.PollImmediateUntil(retryInterval, func() (bool, error) {
		var err error
		if r.agentConfig, r.controllerConfig, err = r.getAntreaConfig(); err != nil {
			klog.Warningf("Could not get Agent and Controller configs from Antrea ConfigMap: %v", err)
			return false, nil
		}
		return true, nil
	}, stopCh); err != nil { // stopCh was closed
		return
	}

	var clusterIdentity clusteridentity.ClusterIdentity
	var creationTime time.Time
	if err := wait.PollImmediateUntil(retryInterval, func() (bool, error) {
		var err error
		if clusterIdentity, creationTime, err = r.clusterIdentityProvider.Get(); err != nil {
			klog.Warningf(
				"Unable to retrieve cluster UUID (does ConfigMap '%s/%s' exist?)",
				defaultAntreaNamespace, clusteridentity.DefaultClusterIdentityConfigMapName,
			)
			return false, nil
		}
		return true, nil
	}, stopCh); err != nil { // stopCh was closed
		return
	}

	r.clusterUUID = clusterIdentity.UUID
	r.antreaDeploymentTime = creationTime

	klog.V(2).Infof("Waiting for %v before sending first usage report", r.ReportInitialDelay)
	time.Sleep(r.ReportInitialDelay)

	wait.Until(func() {
		klog.V(2).Infof("Sending usage report")
		if err := r.sendReport(); err != nil {
			klog.V(2).Infof("Error when sending usage report: %v", err)
			return
		}
		klog.V(2).Infof("Usage report sent successfully")
	}, r.ReportInterval, stopCh)
}
